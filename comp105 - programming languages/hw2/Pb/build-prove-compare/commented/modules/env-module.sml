(* <env-module.sml>=                            *)
structure ListEnv :> ENV where type name = string
                           and type 'a env = (string * 'a) list =
struct
  

(*****************************************************************)
(*                                                               *)
(*   SUPPORT FOR NAMES AND ENVIRONMENTS                          *)
(*                                                               *)
(*****************************************************************)

(* Interlude: micro-Scheme in ML                *)
(*                                              *)
(* [*] \invisiblelocaltableofcontents[*]        *)
(*                                              *)
(* {epigram}Conversation with David R. Hanson, coauthor *)
(* of A Retargetable C Compiler: Design and     *)
(* Implementation\break\citep                   *)
(* hanson-fraser:retargetable:book.             *)
(*                                              *)
(*  \myblock=\wd0 =0.8=0pt                      *)
(*                                              *)
(*  to \myblock\upshapeHanson: C is a lousy language *)
(*  to write a compiler in.                     *)
(*                                              *)
(* {epigram} The interpreters in Chapters [->] through  *)
(* [->] are written in C. C has many properties to *)
(* recommend it: it is relatively small and simple; *)
(* it is widely known and widely supported; it has a *)
(* perspicuous cost model in which it is easy to *)
(* discover what is happening at the machine level; and *)
(* it provides pointer arithmetic, which makes it a very *)
(* good language in which to write a garbage collector. *)
(* But as we move to more complicated and more ambitious *)
(* bridge languages, C is less than ideal. In this and *)
(* succeeding chapters, I therefore present interpreters *)
(* written in the functional language Standard ML. *)
(*                                              *)
(* Standard ML is particularly well suited to symbolic *)
(* computing, especially functions that operate on *)
(* abstract-syntax trees. And an ML program can *)
(* illustrate connections between language design, *)
(* formal semantics, and implementations much more *)
(* clearly than a C program can. Some of the advantages *)
(* of ML are detailed in the sidebar on \cpageref *)
(* mlscheme.good-ml. In this chapter, and also in \cref *)
(* mlinterps.chap,lazyparse.chap, I develop     *)
(* infrastructure used to write interpreters in ML. *)
(* So that you can focus on the new infrastructure, *)
(* I apply it to a familiar language: I present another *)
(* interpreter for micro-Scheme.                *)
(*                                              *)
(* {sidebar}Helpful properties of the ML family of *)
(* languages [*]                                *)
(*                                              *)
(*  \advance\parsepby -5.5pt \advance\itemsepby *)
(*  -5.5pt                                      *)
(*   • ML is a safe language: there is no such thing as *)
(*  an unchecked run-time error, which means there *)
(*  are no bad behaviors that are entirely up to the *)
(*  programmer to avoid.                        *)
(*   • Like Scheme, ML is naturally polymorphic. *)
(*  Polymorphism simplifies everything. For example, *)
(*  unlike the C code in \crefrange             *)
(*  impcore.chapgcs.chap, our ML code uses one  *)
(*  representation of lists and one length function. *)
(*  The C code in \crefcinterps.chap defines three *)
(*  different types of streams, each with its own *)
(*  [[get]] function; the ML code in \cref      *)
(*  mlinterps.chap defines one one type of stream and *)
(*  one [[streamGet]] function. As a final example, *)
(*  because Impcore and micro-Scheme use different *)
(*  environments, each has its own [[process_tests]] *)
(*  function for running unit tests. The ML version *)
(*  in \crefmlinterps.processTests is polymorphic in *)
(*  the environment or environments, and it is shared *)
(*  among all interpreters.                     *)
(*                                              *)
(*  These individual savings in code add up to a lot. *)
(*  More important, when code is polymorphic and is *)
(*  shared among interpreters, you can be certain *)
(*  that whatever that code implements is also the *)
(*  same among languages—polymorphism makes it easier *)
(*  for you to see what is the same and what is *)
(*  different.                                  *)
(*   • Unlike Scheme, ML guarantees internal consistency *)
(*  of polymorphic data structures. For example, *)
(*  if one element of a list is a value, every  *)
(*  element of that list is a value. Such a list can *)
(*  be passed to a polymorphic function like    *)
(*  [[length]], and the same list can be used in a *)
(*  context where only a list of values is      *)
(*  acceptable, like the implementation of function *)
(*  application in [[eval]]. And all of this happens *)
(*  without requiring any variable declarations or *)
(*  type annotations to be written in the code. *)
(*                                              *)
(*  If any of this talk of polymorphism mystifies *)
(*  you, don't worry; polymorphism in programming *)
(*  languages is an important topic in its own right. *)
(*  \creftypesys.chap introduces and defines    *)
(*  polymorphism; \crefml.chap shows how ML provides *)
(*  a limited form of polymorphism without type *)
(*  annotations; and \crefmcl.chap shows a form of *)
(*  polymorphism that makes type annotations    *)
(*  practical.                                  *)
(*   • Like Scheme, ML provides first-class, nested *)
(*  functions, and its initial basis contains useful *)
(*  higher-order functions. These functions help me *)
(*  simplify and clarify the code. For example, in C, *)
(*  running a list of unit tests back-to-front  *)
(*  requires two special-purpose functions: one for *)
(*  Impcore and one for micro-Scheme. In ML, I just *)
(*  use [[foldr]].                              *)
(*   • To detect and signal errors, ML provides *)
(*  exception handlers and exceptions. These    *)
(*  constructs are more flexible and easier to use *)
(*  then C's [[setjmp]] and [[longjmp]].        *)
(*   • Finally, least familiar but most important, *)
(*  ML provides native support for algebraic data *)
(*  types, which I use to represent both abstract *)
(*  syntax and values. These types provide value *)
(*  constructors like the [[IFX]] or [[APPLY]] used *)
(*  in previous chapters, but instead of [[switch]] *)
(*  statements, ML provides pattern matching. Using *)
(*  pattern matching enables me to write function *)
(*  definitions that look a lot like algebraic laws. *)
(*  Such definitions are easier to follow than  *)
(*  C code. A detailed explanation accompanies the *)
(*  definition of function [[valueString]] on \ *)
(*  cpagerefmlscheme.code.valueString.          *)
(*                                              *)
(*  Algebraic data types are explained in detail in \ *)
(*  crefadt.chap, which presents the bridge language *)
(*  uML. uML like micro-Scheme plus algebraic data *)
(*  types. Like all chapters in this book, \cref *)
(*  adt.chap presents both the use and the      *)
(*  implementation of algebraic data types.     *)
(*  To understand the implementation, you will want *)
(*  to understand implementations in \cref      *)
(*  typesys.chap,ml.chap, but to understand how *)
(*  algebraic data types are used, you could jump *)
(*  ahead and look at \crefadt.howto right now. *)
(*                                              *)
(* {sidebar}                                    *)
(*                                              *)
(* The micro-Scheme interpreter in this chapter has the *)
(* same structure as the interpreter in Chapter [->]; as *)
(* before, we have environments, abstract syntax, *)
(* primitives, an evaluator for expressions, an *)
(* evaluator for definitions, and a read-eval-print *)
(* loop. Many details are as similar as I can make them, *)
(* but many are not: I want my ML code to look like ML *)
(* and my C code to look like C; that matters more than *)
(* having either look like the other. You will have an *)
(* easier time reading the ML code if you know my *)
(* programming conventions.                     *)
(*                                              *)
(*   • Names of types are written in lowercase letters *)
(*  with words separated by underscores, like   *)
(*  [[exp]], [[def]], or [[unit_test]]. Names of *)
(*  functions and variables begin with lowercase *)
(*  letters, like [[eval]] or [[evaldef]], but long *)
(*  names may be written in ``camel case'' with a mix *)
(*  of uppercase and lowercase letters, like    *)
(*  [[processTests]] instead of the C-style     *)
(*  [[process_tests]]. (Rarely, I may use an    *)
(*  underscore in the name of a local variable.) *)
(*                                              *)
(*  Names of exceptions are capitalized, like   *)
(*  [[NotFound]] or [[RuntimeError]], and they use *)
(*  camel case. Names of value constructors, which *)
(*  identify alternatives in algebraic data types, *)
(*  are written in all capitals, possibly with  *)
(*  underscores, like [[IFX]], [[APPLY]], or    *)
(*  [[CHECK_EXPECT]] (just like enumeration literals *)
(*  in C).                                      *)
(*                                              *)
(*  These conventions are recommended by the SML'97 *)
(*  Standard Basis Library [cite gansner:basis]. *)
(*   • If you happen to be a seasoned ML programmer, *)
(*  you'll notice something missing: there are no *)
(*  modules. Avoiding modules is poor style, and it *)
(*  makes it impossible to take full advantage of the *)
(*  libraries that come with many implementations *)
(*  of ML, including Standard ML of New Jersey and *)
(*  Moscow ML. And without modules, there's no  *)
(*  sensible way to define abstract types. But the *)
(*  Standard ML module system is overly complicated *)
(*  and burdened with legacy features, and if I don't *)
(*  use it, you don't have to learn it. Avoiding *)
(*  modules gives you a good chance to digest this *)
(*  chapter even if your only previous experience *)
(*  with functional languages is your work with *)
(*  micro-Scheme in Chapter [->].               *)
(*                                              *)
(*  Because I don't use ML modules, I have no formal *)
(*  way to talk about interfaces and to distinguish *)
(*  interfaces from implementations. I work around *)
(*  this problem using a literate-programming trick: *)
(*  I put the types of functions and values, which is *)
(*  mostly what ML interfaces describe, in boxes *)
(*  preceding the implementations. This technique *)
(*  makes it possible to present an interface   *)
(*  formally just before I present its          *)
(*  implementation. The Noweb processor ensures that *)
(*  the material in the boxes is checked by the *)
(*  ML compiler.                                *)
(*                                              *)
(* A final aspect of my ML code is less a matter of *)
(* convention than of necessity: ML is persnickety about *)
(* the order in which definitions appear, and it has *)
(* miserable support for mutual recursion. These *)
(* properties are limitations that I have to work *)
(* around.                                      *)
(*                                              *)
(* The relevant differences between ML and C start with *)
(* syntactic categories: at top level, C has both *)
(* declarations and definitions, but ML has only *)
(* definitions. C's syntactic structure makes it *)
(* possible to be relatively careless about the order in *)
(* which things appear: declare all your structures *)
(* (probably in [[typedef]]s) in any order you like, and *)
(* you can define them in just about any order you like. *)
(* Then declare all your functions in any order you *)
(* like, and you can define them in any order you like. *)
(* Easy. Of course there are drawbacks: only a  *)
(* definition can initialize a variable, and global *)
(* variables can be initialized only in limited ways. *)
(* And it's too easy to define circular structures that *)
(* allow you to chase pointers forever—or into no-man's *)
(* land.                                        *)
(*                                              *)
(* ML's syntactic structure requires you to be careful *)
(* about the order in which things appear: the  *)
(* definition of a name may appear only after the *)
(* definitions of all the other names it refers to. *)
(* Of course there are benefits: every definition *)
(* initializes its name, and initialization may use any *)
(* valid expression, including [[let]] expressions with *)
(* nested definitions. So it is impossible to define *)
(* circular structures that allow you to chase pointers *)
(* forever; as a consequence, any structurally recursive *)
(* function is guaranteed to terminate. ML's designers *)
(* thought this guarantee was more important than the *)
(* convenience of writing definitions in many orders. *)
(* (And to be fair, using ML modules makes it relatively *)
(* convenient to get things in the right order.) In this *)
(* book, groups of related definitions are put into *)
(* Noweb code chunks like [[<<support for names and *)
(* environments>>]]. I carefully stick together larger *)
(* and larger chunks until eventually I wind up with a *)
(* complete interpreter in a chunk like         *)
(* [[]].                                        *)
(*                                              *)
(* What about mutual recursion? Suppose for example, *)
(* that type [[exp]] refers to [[value]] and type *)
(* [[value]] refers to [[exp]]? Mutually recursive *)
(* definitions like [[exp]] and [[value]] are written *)
(* together, adjacent in the source code, connected with *)
(* the keyword [[and]]. (You won't see [[and]] often, *)
(* but when you do, please remember this: [[and]] always *)
(* means mutual recursion, never any kind of Boolean *)
(* operation.) Mutually recursive function definitions *)
(* provide more options: you can join them with [[and]], *)
(* but it is usually more convenient and more idiomatic *)
(* to nest one inside the other using a [[let]] *)
(* binding—you would use [[and]] only when both mutually *)
(* recursive functions need to be called by some third, *)
(* client function. You can also make functions mutually *)
(* recursive by passing one to another as a parameter. [ *)
(* You can use the parameter trick with types as well, *)
(* but the technique, which is called ``two-level *)
(* types,'' \cite{sheard:generic}, is beyond the scope *)
(* of this book.] Wherever I use mutual recursion, I say *)
(* what technique I use. Now, on to the code!   *)
(*                                              *)
(* Names and environments                       *)
(*                                              *)
(* In my C code, names are an abstract type, and two *)
(* names are equal if any only if they are the same *)
(* pointer, so I can compare them using C's built-in [[= *)
(* =]] operator. In ML, strings are immutable and can be *)
(* meaningfully compared using ML's built-in [[=]] *)
(* operator, so I choose to represent names as strings. *)
(* \mlslabelname                                *)
(* <support for names and environments>=        *)
type name = string
(* The [[type]] syntax here is like C's [[typedef]], it *)
(* defines a type by type abbreviation.         *)

(* In the code, function [[find]] is closely related to *)
(* the [[find]] from \crefscheme.chap: it returns *)
(* whatever is in the environment, which has type [['a]] *)
(* and not type [[Value *]]. But [[bind]] and   *)
(* [[bindList]] are more loosely related to \cref *)
(* scheme.chap's [[bindalloc]] and [[bindalloclist]]: *)
(* although the ML versions add bindings, they do not *)
(* allocate. (The phrases in the box are adapted from *)
(* declarations that appear in the interfaces to ML *)
(* modules; through some Noweb hackery, the declarations *)
(* are checked by the ML compiler.) \mlsflabel  *)
(* bindList,find,bind \mlslabelenv              *)
(* <support for names and environments>=        *)
type 'a env = (name * 'a) list
val emptyEnv = []

(* lookup and check of existing bindings *)
exception NotFound of name
fun find (name, []) = raise NotFound name
  | find (name, (n, v)::tail) = if name = n then v else find (name, tail)

(* adding new bindings *)
exception BindListLength
fun bind (name, v, rho) = (name, v) :: rho
fun bindList (n::vars, v::vals, rho) = bindList (vars, vals, bind (n, v, rho))
  | bindList ([], [], rho) = rho
  | bindList _ = raise BindListLength
(*unboxval*)
(* As in \crefscheme.chap, duplicate names are treated *)
(* as run-time errors. If a name x occurs more than *)
(* twice on a list, function [[duplicatename]] returns \ *)
(* monoSOME x; otherwise it returns [[NONE]].   *)
(* <support for names and environments>=        *)
fun duplicatename [] = NONE
  | duplicatename (x::xs) =
      if List.exists (fn x' => x' = x) xs then
        SOME x
      else
        duplicatename xs
(*unboxval*)
end
                                                                
structure Env :> ENV where type name = string = struct
  

(*****************************************************************)
(*                                                               *)
(*   SUPPORT FOR NAMES AND ENVIRONMENTS                          *)
(*                                                               *)
(*****************************************************************)

(* Interlude: micro-Scheme in ML                *)
(*                                              *)
(* [*] \invisiblelocaltableofcontents[*]        *)
(*                                              *)
(* {epigram}Conversation with David R. Hanson, coauthor *)
(* of A Retargetable C Compiler: Design and     *)
(* Implementation\break\citep                   *)
(* hanson-fraser:retargetable:book.             *)
(*                                              *)
(*  \myblock=\wd0 =0.8=0pt                      *)
(*                                              *)
(*  to \myblock\upshapeHanson: C is a lousy language *)
(*  to write a compiler in.                     *)
(*                                              *)
(* {epigram} The interpreters in Chapters [->] through  *)
(* [->] are written in C. C has many properties to *)
(* recommend it: it is relatively small and simple; *)
(* it is widely known and widely supported; it has a *)
(* perspicuous cost model in which it is easy to *)
(* discover what is happening at the machine level; and *)
(* it provides pointer arithmetic, which makes it a very *)
(* good language in which to write a garbage collector. *)
(* But as we move to more complicated and more ambitious *)
(* bridge languages, C is less than ideal. In this and *)
(* succeeding chapters, I therefore present interpreters *)
(* written in the functional language Standard ML. *)
(*                                              *)
(* Standard ML is particularly well suited to symbolic *)
(* computing, especially functions that operate on *)
(* abstract-syntax trees. And an ML program can *)
(* illustrate connections between language design, *)
(* formal semantics, and implementations much more *)
(* clearly than a C program can. Some of the advantages *)
(* of ML are detailed in the sidebar on \cpageref *)
(* mlscheme.good-ml. In this chapter, and also in \cref *)
(* mlinterps.chap,lazyparse.chap, I develop     *)
(* infrastructure used to write interpreters in ML. *)
(* So that you can focus on the new infrastructure, *)
(* I apply it to a familiar language: I present another *)
(* interpreter for micro-Scheme.                *)
(*                                              *)
(* {sidebar}Helpful properties of the ML family of *)
(* languages [*]                                *)
(*                                              *)
(*  \advance\parsepby -5.5pt \advance\itemsepby *)
(*  -5.5pt                                      *)
(*   • ML is a safe language: there is no such thing as *)
(*  an unchecked run-time error, which means there *)
(*  are no bad behaviors that are entirely up to the *)
(*  programmer to avoid.                        *)
(*   • Like Scheme, ML is naturally polymorphic. *)
(*  Polymorphism simplifies everything. For example, *)
(*  unlike the C code in \crefrange             *)
(*  impcore.chapgcs.chap, our ML code uses one  *)
(*  representation of lists and one length function. *)
(*  The C code in \crefcinterps.chap defines three *)
(*  different types of streams, each with its own *)
(*  [[get]] function; the ML code in \cref      *)
(*  mlinterps.chap defines one one type of stream and *)
(*  one [[streamGet]] function. As a final example, *)
(*  because Impcore and micro-Scheme use different *)
(*  environments, each has its own [[process_tests]] *)
(*  function for running unit tests. The ML version *)
(*  in \crefmlinterps.processTests is polymorphic in *)
(*  the environment or environments, and it is shared *)
(*  among all interpreters.                     *)
(*                                              *)
(*  These individual savings in code add up to a lot. *)
(*  More important, when code is polymorphic and is *)
(*  shared among interpreters, you can be certain *)
(*  that whatever that code implements is also the *)
(*  same among languages—polymorphism makes it easier *)
(*  for you to see what is the same and what is *)
(*  different.                                  *)
(*   • Unlike Scheme, ML guarantees internal consistency *)
(*  of polymorphic data structures. For example, *)
(*  if one element of a list is a value, every  *)
(*  element of that list is a value. Such a list can *)
(*  be passed to a polymorphic function like    *)
(*  [[length]], and the same list can be used in a *)
(*  context where only a list of values is      *)
(*  acceptable, like the implementation of function *)
(*  application in [[eval]]. And all of this happens *)
(*  without requiring any variable declarations or *)
(*  type annotations to be written in the code. *)
(*                                              *)
(*  If any of this talk of polymorphism mystifies *)
(*  you, don't worry; polymorphism in programming *)
(*  languages is an important topic in its own right. *)
(*  \creftypesys.chap introduces and defines    *)
(*  polymorphism; \crefml.chap shows how ML provides *)
(*  a limited form of polymorphism without type *)
(*  annotations; and \crefmcl.chap shows a form of *)
(*  polymorphism that makes type annotations    *)
(*  practical.                                  *)
(*   • Like Scheme, ML provides first-class, nested *)
(*  functions, and its initial basis contains useful *)
(*  higher-order functions. These functions help me *)
(*  simplify and clarify the code. For example, in C, *)
(*  running a list of unit tests back-to-front  *)
(*  requires two special-purpose functions: one for *)
(*  Impcore and one for micro-Scheme. In ML, I just *)
(*  use [[foldr]].                              *)
(*   • To detect and signal errors, ML provides *)
(*  exception handlers and exceptions. These    *)
(*  constructs are more flexible and easier to use *)
(*  then C's [[setjmp]] and [[longjmp]].        *)
(*   • Finally, least familiar but most important, *)
(*  ML provides native support for algebraic data *)
(*  types, which I use to represent both abstract *)
(*  syntax and values. These types provide value *)
(*  constructors like the [[IFX]] or [[APPLY]] used *)
(*  in previous chapters, but instead of [[switch]] *)
(*  statements, ML provides pattern matching. Using *)
(*  pattern matching enables me to write function *)
(*  definitions that look a lot like algebraic laws. *)
(*  Such definitions are easier to follow than  *)
(*  C code. A detailed explanation accompanies the *)
(*  definition of function [[valueString]] on \ *)
(*  cpagerefmlscheme.code.valueString.          *)
(*                                              *)
(*  Algebraic data types are explained in detail in \ *)
(*  crefadt.chap, which presents the bridge language *)
(*  uML. uML like micro-Scheme plus algebraic data *)
(*  types. Like all chapters in this book, \cref *)
(*  adt.chap presents both the use and the      *)
(*  implementation of algebraic data types.     *)
(*  To understand the implementation, you will want *)
(*  to understand implementations in \cref      *)
(*  typesys.chap,ml.chap, but to understand how *)
(*  algebraic data types are used, you could jump *)
(*  ahead and look at \crefadt.howto right now. *)
(*                                              *)
(* {sidebar}                                    *)
(*                                              *)
(* The micro-Scheme interpreter in this chapter has the *)
(* same structure as the interpreter in Chapter [->]; as *)
(* before, we have environments, abstract syntax, *)
(* primitives, an evaluator for expressions, an *)
(* evaluator for definitions, and a read-eval-print *)
(* loop. Many details are as similar as I can make them, *)
(* but many are not: I want my ML code to look like ML *)
(* and my C code to look like C; that matters more than *)
(* having either look like the other. You will have an *)
(* easier time reading the ML code if you know my *)
(* programming conventions.                     *)
(*                                              *)
(*   • Names of types are written in lowercase letters *)
(*  with words separated by underscores, like   *)
(*  [[exp]], [[def]], or [[unit_test]]. Names of *)
(*  functions and variables begin with lowercase *)
(*  letters, like [[eval]] or [[evaldef]], but long *)
(*  names may be written in ``camel case'' with a mix *)
(*  of uppercase and lowercase letters, like    *)
(*  [[processTests]] instead of the C-style     *)
(*  [[process_tests]]. (Rarely, I may use an    *)
(*  underscore in the name of a local variable.) *)
(*                                              *)
(*  Names of exceptions are capitalized, like   *)
(*  [[NotFound]] or [[RuntimeError]], and they use *)
(*  camel case. Names of value constructors, which *)
(*  identify alternatives in algebraic data types, *)
(*  are written in all capitals, possibly with  *)
(*  underscores, like [[IFX]], [[APPLY]], or    *)
(*  [[CHECK_EXPECT]] (just like enumeration literals *)
(*  in C).                                      *)
(*                                              *)
(*  These conventions are recommended by the SML'97 *)
(*  Standard Basis Library [cite gansner:basis]. *)
(*   • If you happen to be a seasoned ML programmer, *)
(*  you'll notice something missing: there are no *)
(*  modules. Avoiding modules is poor style, and it *)
(*  makes it impossible to take full advantage of the *)
(*  libraries that come with many implementations *)
(*  of ML, including Standard ML of New Jersey and *)
(*  Moscow ML. And without modules, there's no  *)
(*  sensible way to define abstract types. But the *)
(*  Standard ML module system is overly complicated *)
(*  and burdened with legacy features, and if I don't *)
(*  use it, you don't have to learn it. Avoiding *)
(*  modules gives you a good chance to digest this *)
(*  chapter even if your only previous experience *)
(*  with functional languages is your work with *)
(*  micro-Scheme in Chapter [->].               *)
(*                                              *)
(*  Because I don't use ML modules, I have no formal *)
(*  way to talk about interfaces and to distinguish *)
(*  interfaces from implementations. I work around *)
(*  this problem using a literate-programming trick: *)
(*  I put the types of functions and values, which is *)
(*  mostly what ML interfaces describe, in boxes *)
(*  preceding the implementations. This technique *)
(*  makes it possible to present an interface   *)
(*  formally just before I present its          *)
(*  implementation. The Noweb processor ensures that *)
(*  the material in the boxes is checked by the *)
(*  ML compiler.                                *)
(*                                              *)
(* A final aspect of my ML code is less a matter of *)
(* convention than of necessity: ML is persnickety about *)
(* the order in which definitions appear, and it has *)
(* miserable support for mutual recursion. These *)
(* properties are limitations that I have to work *)
(* around.                                      *)
(*                                              *)
(* The relevant differences between ML and C start with *)
(* syntactic categories: at top level, C has both *)
(* declarations and definitions, but ML has only *)
(* definitions. C's syntactic structure makes it *)
(* possible to be relatively careless about the order in *)
(* which things appear: declare all your structures *)
(* (probably in [[typedef]]s) in any order you like, and *)
(* you can define them in just about any order you like. *)
(* Then declare all your functions in any order you *)
(* like, and you can define them in any order you like. *)
(* Easy. Of course there are drawbacks: only a  *)
(* definition can initialize a variable, and global *)
(* variables can be initialized only in limited ways. *)
(* And it's too easy to define circular structures that *)
(* allow you to chase pointers forever—or into no-man's *)
(* land.                                        *)
(*                                              *)
(* ML's syntactic structure requires you to be careful *)
(* about the order in which things appear: the  *)
(* definition of a name may appear only after the *)
(* definitions of all the other names it refers to. *)
(* Of course there are benefits: every definition *)
(* initializes its name, and initialization may use any *)
(* valid expression, including [[let]] expressions with *)
(* nested definitions. So it is impossible to define *)
(* circular structures that allow you to chase pointers *)
(* forever; as a consequence, any structurally recursive *)
(* function is guaranteed to terminate. ML's designers *)
(* thought this guarantee was more important than the *)
(* convenience of writing definitions in many orders. *)
(* (And to be fair, using ML modules makes it relatively *)
(* convenient to get things in the right order.) In this *)
(* book, groups of related definitions are put into *)
(* Noweb code chunks like [[<<support for names and *)
(* environments>>]]. I carefully stick together larger *)
(* and larger chunks until eventually I wind up with a *)
(* complete interpreter in a chunk like         *)
(* [[]].                                        *)
(*                                              *)
(* What about mutual recursion? Suppose for example, *)
(* that type [[exp]] refers to [[value]] and type *)
(* [[value]] refers to [[exp]]? Mutually recursive *)
(* definitions like [[exp]] and [[value]] are written *)
(* together, adjacent in the source code, connected with *)
(* the keyword [[and]]. (You won't see [[and]] often, *)
(* but when you do, please remember this: [[and]] always *)
(* means mutual recursion, never any kind of Boolean *)
(* operation.) Mutually recursive function definitions *)
(* provide more options: you can join them with [[and]], *)
(* but it is usually more convenient and more idiomatic *)
(* to nest one inside the other using a [[let]] *)
(* binding—you would use [[and]] only when both mutually *)
(* recursive functions need to be called by some third, *)
(* client function. You can also make functions mutually *)
(* recursive by passing one to another as a parameter. [ *)
(* You can use the parameter trick with types as well, *)
(* but the technique, which is called ``two-level *)
(* types,'' \cite{sheard:generic}, is beyond the scope *)
(* of this book.] Wherever I use mutual recursion, I say *)
(* what technique I use. Now, on to the code!   *)
(*                                              *)
(* Names and environments                       *)
(*                                              *)
(* In my C code, names are an abstract type, and two *)
(* names are equal if any only if they are the same *)
(* pointer, so I can compare them using C's built-in [[= *)
(* =]] operator. In ML, strings are immutable and can be *)
(* meaningfully compared using ML's built-in [[=]] *)
(* operator, so I choose to represent names as strings. *)
(* \mlslabelname                                *)
(* <support for names and environments>=        *)
type name = string
(* The [[type]] syntax here is like C's [[typedef]], it *)
(* defines a type by type abbreviation.         *)

(* In the code, function [[find]] is closely related to *)
(* the [[find]] from \crefscheme.chap: it returns *)
(* whatever is in the environment, which has type [['a]] *)
(* and not type [[Value *]]. But [[bind]] and   *)
(* [[bindList]] are more loosely related to \cref *)
(* scheme.chap's [[bindalloc]] and [[bindalloclist]]: *)
(* although the ML versions add bindings, they do not *)
(* allocate. (The phrases in the box are adapted from *)
(* declarations that appear in the interfaces to ML *)
(* modules; through some Noweb hackery, the declarations *)
(* are checked by the ML compiler.) \mlsflabel  *)
(* bindList,find,bind \mlslabelenv              *)
(* <support for names and environments>=        *)
type 'a env = (name * 'a) list
val emptyEnv = []

(* lookup and check of existing bindings *)
exception NotFound of name
fun find (name, []) = raise NotFound name
  | find (name, (n, v)::tail) = if name = n then v else find (name, tail)

(* adding new bindings *)
exception BindListLength
fun bind (name, v, rho) = (name, v) :: rho
fun bindList (n::vars, v::vals, rho) = bindList (vars, vals, bind (n, v, rho))
  | bindList ([], [], rho) = rho
  | bindList _ = raise BindListLength
(*unboxval*)
(* As in \crefscheme.chap, duplicate names are treated *)
(* as run-time errors. If a name x occurs more than *)
(* twice on a list, function [[duplicatename]] returns \ *)
(* monoSOME x; otherwise it returns [[NONE]].   *)
(* <support for names and environments>=        *)
fun duplicatename [] = NONE
  | duplicatename (x::xs) =
      if List.exists (fn x' => x' = x) xs then
        SOME x
      else
        duplicatename xs
(*unboxval*)
end
